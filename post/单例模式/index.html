<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My New Hugo Site </title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.49" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.e08a958ae3e530145318b6373195c765.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="" />
<meta property="og:description" content=" 单例模式 单例是一种对全局变量的改进，你无法用错误的类型数据覆写一个单例。  单例模式和全局变量都可以在系统中任意地方被访问。同时造成误用。 可能会导致很强的依赖关系，如果改变单例那么所有使用该单例的类都会受到影响。   单例对象的全局化的性质会是程序员绕过类接口定义的通信线路.当单例被使用时，依赖便会隐藏于方法内部，并不会出现在方法声明中，使得依赖难以追踪。  preferences 对象应该可以被系统中任何对象使用 不应该被存储在被覆写的全局变量中 不应超过一个preferences对象，假设y设置pref一个属性， z对象不需要通过其他对象就可以直接获得该属性的值。    class preferences{ private $props = array();    private static $instance; //只能被类调用而不是对象调用    private function __construct(){ }    public static function getinstance(){ if(empty(self::$instance)){ self::$instance = new preferences(); }//访问静态属性，当为空时创建对象，并保存在静态属性中 return self::$instance; }    static function static_getinstance(){ if(empty(self::$instance)){ self::$instance = new static();//通过static关键字调用 } return self::$instance; } public function setproperty($key,$val){ $this-&gt;propos[$key] =$val; } public function getproperty($key){ return $this-&gt;propos[$key]; } } $pref = preferences::getinstance(); $pref-&gt;setproperty(&quot;name&quot;,&quot;jack&quot;); //echo $pref-&gt;getproperty(&#39;name&#39;); unset($pref);//移除引用 $pref2=preferences::getinstance(); echo $pref2-&gt;getproperty(&#39;name&#39;); //jack $pref2-&gt;setproperty(&quot;name&quot;,&quot;Rosie&quot;); // unset($pref2); $pref3=preferences::static_getinstance(); echo $pref3-&gt;getproperty(&#39;name&#39;); //Rosie  " />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://gitgitcode.github.io/post/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" />

<meta itemprop="name" content="">
<meta itemprop="description" content=" 单例模式 单例是一种对全局变量的改进，你无法用错误的类型数据覆写一个单例。  单例模式和全局变量都可以在系统中任意地方被访问。同时造成误用。 可能会导致很强的依赖关系，如果改变单例那么所有使用该单例的类都会受到影响。   单例对象的全局化的性质会是程序员绕过类接口定义的通信线路.当单例被使用时，依赖便会隐藏于方法内部，并不会出现在方法声明中，使得依赖难以追踪。  preferences 对象应该可以被系统中任何对象使用 不应该被存储在被覆写的全局变量中 不应超过一个preferences对象，假设y设置pref一个属性， z对象不需要通过其他对象就可以直接获得该属性的值。    class preferences{ private $props = array();    private static $instance; //只能被类调用而不是对象调用    private function __construct(){ }    public static function getinstance(){ if(empty(self::$instance)){ self::$instance = new preferences(); }//访问静态属性，当为空时创建对象，并保存在静态属性中 return self::$instance; }    static function static_getinstance(){ if(empty(self::$instance)){ self::$instance = new static();//通过static关键字调用 } return self::$instance; } public function setproperty($key,$val){ $this-&gt;propos[$key] =$val; } public function getproperty($key){ return $this-&gt;propos[$key]; } } $pref = preferences::getinstance(); $pref-&gt;setproperty(&quot;name&quot;,&quot;jack&quot;); //echo $pref-&gt;getproperty(&#39;name&#39;); unset($pref);//移除引用 $pref2=preferences::getinstance(); echo $pref2-&gt;getproperty(&#39;name&#39;); //jack $pref2-&gt;setproperty(&quot;name&quot;,&quot;Rosie&quot;); // unset($pref2); $pref3=preferences::static_getinstance(); echo $pref3-&gt;getproperty(&#39;name&#39;); //Rosie  ">



<meta itemprop="wordCount" content="80">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content=" 单例模式 单例是一种对全局变量的改进，你无法用错误的类型数据覆写一个单例。  单例模式和全局变量都可以在系统中任意地方被访问。同时造成误用。 可能会导致很强的依赖关系，如果改变单例那么所有使用该单例的类都会受到影响。   单例对象的全局化的性质会是程序员绕过类接口定义的通信线路.当单例被使用时，依赖便会隐藏于方法内部，并不会出现在方法声明中，使得依赖难以追踪。  preferences 对象应该可以被系统中任何对象使用 不应该被存储在被覆写的全局变量中 不应超过一个preferences对象，假设y设置pref一个属性， z对象不需要通过其他对象就可以直接获得该属性的值。    class preferences{ private $props = array();    private static $instance; //只能被类调用而不是对象调用    private function __construct(){ }    public static function getinstance(){ if(empty(self::$instance)){ self::$instance = new preferences(); }//访问静态属性，当为空时创建对象，并保存在静态属性中 return self::$instance; }    static function static_getinstance(){ if(empty(self::$instance)){ self::$instance = new static();//通过static关键字调用 } return self::$instance; } public function setproperty($key,$val){ $this-&gt;propos[$key] =$val; } public function getproperty($key){ return $this-&gt;propos[$key]; } } $pref = preferences::getinstance(); $pref-&gt;setproperty(&quot;name&quot;,&quot;jack&quot;); //echo $pref-&gt;getproperty(&#39;name&#39;); unset($pref);//移除引用 $pref2=preferences::getinstance(); echo $pref2-&gt;getproperty(&#39;name&#39;); //jack $pref2-&gt;setproperty(&quot;name&quot;,&quot;Rosie&quot;); // unset($pref2); $pref3=preferences::static_getinstance(); echo $pref3-&gt;getproperty(&#39;name&#39;); //Rosie  "/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://gitgitcode.github.io" class="f3 fw2 hover-white no-underline white-90 dib">
      My New Hugo Site
    </a>
    <div class="flex-l items-center">
      
      









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1"></h1>
      
      <time class="f6 mv4 dib tracked" datetime="0001-01-01T00:00:00Z">January 1, 0001</time>
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h2 id="单例模式">单例模式</h2>

<h4 id="单例是一种对全局变量的改进-你无法用错误的类型数据覆写一个单例">单例是一种对全局变量的改进，你无法用错误的类型数据覆写一个单例。</h4>

<pre><code>    单例模式和全局变量都可以在系统中任意地方被访问。同时造成误用。
    可能会导致很强的依赖关系，如果改变单例那么所有使用该单例的类都会受到影响。
</code></pre>

<blockquote>
<h2 id="单例对象的全局化的性质会是程序员绕过类接口定义的通信线路-当单例被使用时-依赖便会隐藏于方法内部-并不会出现在方法声明中-使得依赖难以追踪">单例对象的全局化的性质会是程序员绕过类接口定义的通信线路.当单例被使用时，依赖便会隐藏于方法内部，并不会出现在方法声明中，使得依赖难以追踪。</h2>

<pre><code>    preferences 
    对象应该可以被系统中任何对象使用
    不应该被存储在被覆写的全局变量中
    不应超过一个preferences对象，假设y设置pref一个属性，
    z对象不需要通过其他对象就可以直接获得该属性的值。
</code></pre>
</blockquote>

<pre><code>    class preferences{
        private $props = array();
</code></pre>

<blockquote>
<pre><code>            private static $instance;
            //只能被类调用而不是对象调用
</code></pre>
</blockquote>

<pre><code>        private function __construct(){

        }
</code></pre>

<blockquote>
<pre><code>        public static function getinstance(){
            if(empty(self::$instance)){
                self::$instance = new preferences();
            }//访问静态属性，当为空时创建对象，并保存在静态属性中
            return self::$instance;
        }
</code></pre>
</blockquote>

<pre><code>        static function static_getinstance(){
            if(empty(self::$instance)){
                self::$instance = new static();//通过static关键字调用
            }
            return self::$instance;
        }

        public function setproperty($key,$val){
            $this-&gt;propos[$key] =$val;
        }

        public function getproperty($key){
            return $this-&gt;propos[$key];
        }

    }

    $pref = preferences::getinstance();
    $pref-&gt;setproperty(&quot;name&quot;,&quot;jack&quot;);
    //echo $pref-&gt;getproperty('name');
    unset($pref);//移除引用
    $pref2=preferences::getinstance();
    echo $pref2-&gt;getproperty('name'); 
    //jack
    $pref2-&gt;setproperty(&quot;name&quot;,&quot;Rosie&quot;);
    //
    unset($pref2); 
    $pref3=preferences::static_getinstance();
    echo $pref3-&gt;getproperty('name');
    //Rosie
</code></pre>
<ul class="pa0">
  
</ul>
<div class="mt6">
        
      </div>
    </main>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://gitgitcode.github.io" >
    &copy; 2018 My New Hugo Site
  </a>
    <div>








</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
