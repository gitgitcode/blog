<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My New Hugo Site </title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.49" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.e08a958ae3e530145318b6373195c765.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="" />
<meta property="og:description" content=" 生成对象和问题和解决方法   abstract class employee{    protected $name; private static $types = array(&#39;minion&#39;,&#39;cluedup&#39;,&#39;wellconneted&#39;); //对象是实例化委托出来 创建对象策略 static function recruit($name){ //静态方法 $num = rand(1,count(self::$types) -1); $class = self::$types[$num]; return new $class($name); } function __construct($name){ $this-&gt;name = $name; } abstract function fire(); }     class minion extends employee{//属下 function fire(){ print &quot;{$this-&gt;name} : i&#39;ll clear my desk&lt;br/&gt;&quot;; } }     class nestyboss{ private $employee = array(); //必须实例化minion 才能获得 minion 对象 function addemployess($employeeName){ $this-&gt;employee[] = new minion($employeeName); } //使用employess 类 多态的方式 但是没有定义创建对象策略 function NewAddEmployess(employee $employee){ $this-&gt;employee[] = $employee; } function projectfails(){ if( count($this-&gt;employee) &gt;0 ){ $emp = array_pop($this-&gt;employee); $emp-&gt;fire(); } } }     class cluedup extends employee{ function fire(){ print &quot;$this-&gt;name : i&#39;ll call my lowyer &lt;br&gt;&quot;; } } $boss= new nestyboss(); $boss-&gt;addemployess(&#39;A&#39;);  //必须实例化minion 才能获得 minion 对象  $boss-&gt;addemployess(&#39;B&#39;);  //必须实例化minion 才能获得 minion 对象  $boss-&gt;NewAddEmployess( new cluedup(&#39;xiaoC&#39;) );//实例化  //创建对象策略  $boss-&gt;NewAddEmployess( employee::recruit(&#39;harry&#39;) ); $boss-&gt;projectfails(); $boss-&gt;projectfails(); $boss-&gt;projectfails(); $boss-&gt;projectfails(); $boss-&gt;projectfails();   通过静态方法实例化，生成对象。  " />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://gitgitcode.github.io/post/%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E5%A4%9A%E6%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%A7%94%E6%89%98/" />

<meta itemprop="name" content="">
<meta itemprop="description" content=" 生成对象和问题和解决方法   abstract class employee{    protected $name; private static $types = array(&#39;minion&#39;,&#39;cluedup&#39;,&#39;wellconneted&#39;); //对象是实例化委托出来 创建对象策略 static function recruit($name){ //静态方法 $num = rand(1,count(self::$types) -1); $class = self::$types[$num]; return new $class($name); } function __construct($name){ $this-&gt;name = $name; } abstract function fire(); }     class minion extends employee{//属下 function fire(){ print &quot;{$this-&gt;name} : i&#39;ll clear my desk&lt;br/&gt;&quot;; } }     class nestyboss{ private $employee = array(); //必须实例化minion 才能获得 minion 对象 function addemployess($employeeName){ $this-&gt;employee[] = new minion($employeeName); } //使用employess 类 多态的方式 但是没有定义创建对象策略 function NewAddEmployess(employee $employee){ $this-&gt;employee[] = $employee; } function projectfails(){ if( count($this-&gt;employee) &gt;0 ){ $emp = array_pop($this-&gt;employee); $emp-&gt;fire(); } } }     class cluedup extends employee{ function fire(){ print &quot;$this-&gt;name : i&#39;ll call my lowyer &lt;br&gt;&quot;; } } $boss= new nestyboss(); $boss-&gt;addemployess(&#39;A&#39;);  //必须实例化minion 才能获得 minion 对象  $boss-&gt;addemployess(&#39;B&#39;);  //必须实例化minion 才能获得 minion 对象  $boss-&gt;NewAddEmployess( new cluedup(&#39;xiaoC&#39;) );//实例化  //创建对象策略  $boss-&gt;NewAddEmployess( employee::recruit(&#39;harry&#39;) ); $boss-&gt;projectfails(); $boss-&gt;projectfails(); $boss-&gt;projectfails(); $boss-&gt;projectfails(); $boss-&gt;projectfails();   通过静态方法实例化，生成对象。  ">



<meta itemprop="wordCount" content="137">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content=" 生成对象和问题和解决方法   abstract class employee{    protected $name; private static $types = array(&#39;minion&#39;,&#39;cluedup&#39;,&#39;wellconneted&#39;); //对象是实例化委托出来 创建对象策略 static function recruit($name){ //静态方法 $num = rand(1,count(self::$types) -1); $class = self::$types[$num]; return new $class($name); } function __construct($name){ $this-&gt;name = $name; } abstract function fire(); }     class minion extends employee{//属下 function fire(){ print &quot;{$this-&gt;name} : i&#39;ll clear my desk&lt;br/&gt;&quot;; } }     class nestyboss{ private $employee = array(); //必须实例化minion 才能获得 minion 对象 function addemployess($employeeName){ $this-&gt;employee[] = new minion($employeeName); } //使用employess 类 多态的方式 但是没有定义创建对象策略 function NewAddEmployess(employee $employee){ $this-&gt;employee[] = $employee; } function projectfails(){ if( count($this-&gt;employee) &gt;0 ){ $emp = array_pop($this-&gt;employee); $emp-&gt;fire(); } } }     class cluedup extends employee{ function fire(){ print &quot;$this-&gt;name : i&#39;ll call my lowyer &lt;br&gt;&quot;; } } $boss= new nestyboss(); $boss-&gt;addemployess(&#39;A&#39;);  //必须实例化minion 才能获得 minion 对象  $boss-&gt;addemployess(&#39;B&#39;);  //必须实例化minion 才能获得 minion 对象  $boss-&gt;NewAddEmployess( new cluedup(&#39;xiaoC&#39;) );//实例化  //创建对象策略  $boss-&gt;NewAddEmployess( employee::recruit(&#39;harry&#39;) ); $boss-&gt;projectfails(); $boss-&gt;projectfails(); $boss-&gt;projectfails(); $boss-&gt;projectfails(); $boss-&gt;projectfails();   通过静态方法实例化，生成对象。  "/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://gitgitcode.github.io" class="f3 fw2 hover-white no-underline white-90 dib">
      My New Hugo Site
    </a>
    <div class="flex-l items-center">
      
      









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1"></h1>
      
      <time class="f6 mv4 dib tracked" datetime="0001-01-01T00:00:00Z">January 1, 0001</time>
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h1 id="生成对象和问题和解决方法">生成对象和问题和解决方法</h1>

<blockquote>
<pre><code>    abstract class employee{
</code></pre>
</blockquote>

<pre><code>        protected $name;

        private static $types = array('minion','cluedup','wellconneted');
          //对象是实例化委托出来  创建对象策略          
        static function recruit($name){ //静态方法
            $num = rand(1,count(self::$types) -1);
            $class = self::$types[$num];
            return new $class($name);
        }

        function __construct($name){
            $this-&gt;name = $name; 
        }
        abstract function fire();
    }
</code></pre>

<blockquote>
</blockquote>

<pre><code>    class minion extends employee{//属下
            function fire(){
                print &quot;{$this-&gt;name} : i'll clear my desk&lt;br/&gt;&quot;;
            }
    }
</code></pre>

<blockquote>
</blockquote>

<pre><code>    class nestyboss{
        private $employee = array();
           //必须实例化minion 才能获得 minion 对象       
        function addemployess($employeeName){ 
             $this-&gt;employee[] = new minion($employeeName);
        }

         //使用employess 类 多态的方式 但是没有定义创建对象策略
        function NewAddEmployess(employee $employee){
            $this-&gt;employee[] = $employee;
        } 

        function projectfails(){
            if( count($this-&gt;employee) &gt;0 ){
                $emp = array_pop($this-&gt;employee);
                $emp-&gt;fire();
            }
        }
    }
</code></pre>

<blockquote>
</blockquote>

<pre><code>    class cluedup extends employee{
        function fire(){
            print &quot;$this-&gt;name : i'll call my lowyer &lt;br&gt;&quot;;
        }
    }

    $boss= new nestyboss();
    $boss-&gt;addemployess('A');
</code></pre>

<h6 id="必须实例化minion-才能获得-minion-对象">//必须实例化minion 才能获得 minion 对象</h6>

<pre><code>    $boss-&gt;addemployess('B');
</code></pre>

<h6 id="必须实例化minion-才能获得-minion-对象-1">//必须实例化minion 才能获得 minion 对象</h6>

<pre><code>    $boss-&gt;NewAddEmployess( new cluedup('xiaoC') );//实例化 
</code></pre>

<h6 id="创建对象策略">//创建对象策略</h6>

<pre><code>    $boss-&gt;NewAddEmployess( employee::recruit('harry') );

    $boss-&gt;projectfails();
    $boss-&gt;projectfails();
    $boss-&gt;projectfails();
    $boss-&gt;projectfails();
    $boss-&gt;projectfails();
</code></pre>

<hr />

<pre><code>    通过静态方法实例化，生成对象。
</code></pre>
<ul class="pa0">
  
</ul>
<div class="mt6">
        
      </div>
    </main>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://gitgitcode.github.io" >
    &copy; 2018 My New Hugo Site
  </a>
    <div>








</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
