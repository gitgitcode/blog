<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My New Hugo Site </title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.49" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.e08a958ae3e530145318b6373195c765.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="" />
<meta property="og:description" content="Hash 算法与数据库实现 标签（空格分隔）： 未分类
Hash 算法与数据库实现 Hash表 （HashTable）又称三列表，通过把关键字Key映射到数组中的一个位置来访问记录，以加快查找速度。 这个映射函数称为Hash函数，存放记录的数组称为Hash表。
Hash 函数 Hash函数的作用是把任意长度的输入，通过hash算法变换成固定长度的输出，概述出就是Hash值。 这种转换是一种压缩映射，就是hash值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出 ，而不可能从Hash值来唯一地确定输入的值。   Hash算法满足条件： 每个关键字都可以均匀地分布到Hash表任意一个位置，并与其他已被散列到Hash表的关键字不发生冲突。  Hash算法 关键字k可能是整数或者字符串，可以按照关键字的类型设计不同的Hash算法。  整数关键字的Hash算法有 &gt;* 直接取余法 &gt;* 乘积取证法 &gt;* Times33
##直接取余法 直接用关键字k除以Hash表的大小m取余数
 h（k）= k mod m  如果hash表的大小为 m = 12 ，所给关键字为k=100，则h（k）=4. 直接求余，速度快。
##乘积取整法
乘积取整法首先使用关键 K 乘以一个常数A（0 &lt; A &lt; 1）, 并取出kA的小数部分。然后用Hash表达小m乘以这个值，再取出整数部分即可。
 h（k）=floor（m*（kA mod 1））  其中，kA mod 1 表示 KA的小数部分，floor是取整操作。 当关键字是字符串的时候，就不能使用上面的Hash算法。因为字符串是有字符组成，所以可以把字符串所有字符的ASCII码加起来得到一个整数，然后再按照上面的Hash算法去计算即可：
# 简单算法描述 不可用于实际开发 function hash_fun($key,$m){ $strlen = strlen($key); $hashval = 0; for($i =0 ;$i&lt;$strlen;$i&#43;&#43;){ $hasval &#43;=ord($key($i)); } return $haval % $m; }  ##经典Hash算法Times33 算法思路就是不断乘以33，效果和随机性都非常好" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://gitgitcode.github.io/post/hash%E7%AE%97%E6%B3%95/" />

<meta itemprop="name" content="">
<meta itemprop="description" content="Hash 算法与数据库实现 标签（空格分隔）： 未分类
Hash 算法与数据库实现 Hash表 （HashTable）又称三列表，通过把关键字Key映射到数组中的一个位置来访问记录，以加快查找速度。 这个映射函数称为Hash函数，存放记录的数组称为Hash表。
Hash 函数 Hash函数的作用是把任意长度的输入，通过hash算法变换成固定长度的输出，概述出就是Hash值。 这种转换是一种压缩映射，就是hash值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出 ，而不可能从Hash值来唯一地确定输入的值。   Hash算法满足条件： 每个关键字都可以均匀地分布到Hash表任意一个位置，并与其他已被散列到Hash表的关键字不发生冲突。  Hash算法 关键字k可能是整数或者字符串，可以按照关键字的类型设计不同的Hash算法。  整数关键字的Hash算法有 &gt;* 直接取余法 &gt;* 乘积取证法 &gt;* Times33
##直接取余法 直接用关键字k除以Hash表的大小m取余数
 h（k）= k mod m  如果hash表的大小为 m = 12 ，所给关键字为k=100，则h（k）=4. 直接求余，速度快。
##乘积取整法
乘积取整法首先使用关键 K 乘以一个常数A（0 &lt; A &lt; 1）, 并取出kA的小数部分。然后用Hash表达小m乘以这个值，再取出整数部分即可。
 h（k）=floor（m*（kA mod 1））  其中，kA mod 1 表示 KA的小数部分，floor是取整操作。 当关键字是字符串的时候，就不能使用上面的Hash算法。因为字符串是有字符组成，所以可以把字符串所有字符的ASCII码加起来得到一个整数，然后再按照上面的Hash算法去计算即可：
# 简单算法描述 不可用于实际开发 function hash_fun($key,$m){ $strlen = strlen($key); $hashval = 0; for($i =0 ;$i&lt;$strlen;$i&#43;&#43;){ $hasval &#43;=ord($key($i)); } return $haval % $m; }  ##经典Hash算法Times33 算法思路就是不断乘以33，效果和随机性都非常好">



<meta itemprop="wordCount" content="437">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Hash 算法与数据库实现 标签（空格分隔）： 未分类
Hash 算法与数据库实现 Hash表 （HashTable）又称三列表，通过把关键字Key映射到数组中的一个位置来访问记录，以加快查找速度。 这个映射函数称为Hash函数，存放记录的数组称为Hash表。
Hash 函数 Hash函数的作用是把任意长度的输入，通过hash算法变换成固定长度的输出，概述出就是Hash值。 这种转换是一种压缩映射，就是hash值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出 ，而不可能从Hash值来唯一地确定输入的值。   Hash算法满足条件： 每个关键字都可以均匀地分布到Hash表任意一个位置，并与其他已被散列到Hash表的关键字不发生冲突。  Hash算法 关键字k可能是整数或者字符串，可以按照关键字的类型设计不同的Hash算法。  整数关键字的Hash算法有 &gt;* 直接取余法 &gt;* 乘积取证法 &gt;* Times33
##直接取余法 直接用关键字k除以Hash表的大小m取余数
 h（k）= k mod m  如果hash表的大小为 m = 12 ，所给关键字为k=100，则h（k）=4. 直接求余，速度快。
##乘积取整法
乘积取整法首先使用关键 K 乘以一个常数A（0 &lt; A &lt; 1）, 并取出kA的小数部分。然后用Hash表达小m乘以这个值，再取出整数部分即可。
 h（k）=floor（m*（kA mod 1））  其中，kA mod 1 表示 KA的小数部分，floor是取整操作。 当关键字是字符串的时候，就不能使用上面的Hash算法。因为字符串是有字符组成，所以可以把字符串所有字符的ASCII码加起来得到一个整数，然后再按照上面的Hash算法去计算即可：
# 简单算法描述 不可用于实际开发 function hash_fun($key,$m){ $strlen = strlen($key); $hashval = 0; for($i =0 ;$i&lt;$strlen;$i&#43;&#43;){ $hasval &#43;=ord($key($i)); } return $haval % $m; }  ##经典Hash算法Times33 算法思路就是不断乘以33，效果和随机性都非常好"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://gitgitcode.github.io" class="f3 fw2 hover-white no-underline white-90 dib">
      My New Hugo Site
    </a>
    <div class="flex-l items-center">
      
      









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  <article class="flex-l flex-wrap justify-between mw8 center ph3 ph0-l">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1"></h1>
      
      <time class="f6 mv4 dib tracked" datetime="0001-01-01T00:00:00Z">January 1, 0001</time>
    </header>

    <main class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h1 id="hash-算法与数据库实现">Hash 算法与数据库实现</h1>

<p>标签（空格分隔）： 未分类</p>

<h2 id="hash-算法与数据库实现-1">Hash 算法与数据库实现</h2>

<p>Hash表 （HashTable）又称三列表，通过把关键字Key映射到数组中的一个位置来访问记录，以加快查找速度。
这个映射函数称为Hash函数，存放记录的数组称为Hash表。</p>

<h3 id="hash-函数">Hash 函数</h3>

<pre><code>Hash函数的作用是把任意长度的输入，通过hash算法变换成固定长度的输出，概述出就是Hash值。
这种转换是一种压缩映射，就是hash值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出
，而不可能从Hash值来唯一地确定输入的值。
</code></pre>

<ul>
<li>Hash算法满足条件：
每个关键字都可以均匀地分布到Hash表任意一个位置，并与其他已被散列到Hash表的关键字不发生冲突。</li>
</ul>

<h3 id="hash算法">Hash算法</h3>

<pre><code>关键字k可能是整数或者字符串，可以按照关键字的类型设计不同的Hash算法。
</code></pre>

<p>整数关键字的Hash算法有
&gt;*   直接取余法
&gt;*   乘积取证法
&gt;*   Times33</p>

<p>##直接取余法
    直接用关键字k除以Hash表的大小m取余数</p>

<pre><code>    h（k）= k mod m
</code></pre>

<p>如果hash表的大小为 m = 12 ，所给关键字为k=100，则h（k）=4.
直接求余，速度快。</p>

<p>##乘积取整法</p>

<p>乘积取整法首先使用关键 K 乘以一个常数A（0 &lt; A &lt; 1）,
并取出kA的小数部分。然后用Hash表达小m乘以这个值，再取出整数部分即可。</p>

<pre><code>    h（k）=floor（m*（kA mod 1））
</code></pre>

<p>其中，kA mod 1 表示 KA的小数部分，floor是取整操作。
当关键字是字符串的时候，就不能使用上面的Hash算法。因为字符串是有字符组成，所以可以把字符串所有字符的ASCII码加起来得到一个整数，然后再按照上面的Hash算法去计算即可：</p>

<pre><code># 简单算法描述 不可用于实际开发
    function hash_fun($key,$m){
        $strlen = strlen($key);
        $hashval = 0;
        for($i =0 ;$i&lt;$strlen;$i++){
            $hasval +=ord($key($i));
        }
        return $haval % $m;
    }
</code></pre>

<p>##经典Hash算法Times33
算法思路就是不断乘以33，效果和随机性都非常好</p>

<pre><code>    unsigned int DJBHash(char *str){
        unsigned int hash= 5381;
        while(*str){
        hash += (hash &lt;&lt; 5)+(*str++)
        }
        return (hash &amp; 0x7FFFFFFFF);
    }
</code></pre>

<p>即是素数（质数），也是奇数。除了33，还有131, 1313, 5381等。PHP内置的Hash函数用的是5381</p>

<h2 id="hash表">Hash表</h2>

<p>Hash是非常重要的数据结构。时间复杂度是O（1）
实现Hash的步骤
创建一个固定大小的数组用于存放数据。
设计Hash函数。
通过Hash函数把关键字映射到某个位置，并在此位置上进行数据存取。</p>

<p>##使用PHP实现Hash表
首先创建一个HashTable类，有两个属性 $buckets 和 $size .$buckets 用于存储数据的数组，$size用于记录$buckets数组大小。
然后在构造函数中为$buckets数组分配内存。</p>

<pre><code>&lt;?php
    class HashTables{
        private $buckets;
        private $size= 10;
        
        public function __construct(){
            $this-&gt;bukets=new SplFixedArray($this-&gt;size);
        }
    }

</code></pre>

<p>构造函数中，为$buckets数组分配了一个大小为10的数组。
SplFixedArray（）是php的SPL扩展，效率更快。（5.3以前版本要开启SPL模块，5.3默认开启）
接着为Hash表制定一个Hash函数，现在使用的字符串相加取余的方法：</p>

<pre><code>    private function hashfunc($key){
        $strlen = strlen($key);
        $hashval=0;
        for($i=0;$i&lt;$strlen;$i++){
            $hashval+=ord($key[$i]);
        }
        return $hashval % $this-&gt;size
    }
</code></pre>

<p>有了Hash函数，就可以实现插入和查找方法。插入数据时，先通过Hash函数计算关键字所在Hash表的位置，然后把数据保存到此为位置即可。</p>

<pre><code>    public function insert($key,$val){
        $index=$this-&gt;hashfunc($key);
        $this-&gt;buckets[$index]=$val;
    }
</code></pre>

<p>查找数据方法与插入方法相似，先通过Hash函数计算关键字所在Hash表的位置，然后返回此位置的数据即可。</p>

<pre><code>    public function find($key){
        $index=$this-&gt;hashfunc($key);
        return $this-&gt;buckets[$index];
    }
</code></pre>

<p>完整的代码及测试</p>

<pre><code>&lt;?php
    class HashTable{
        private $buckets;
        private $size=10;
        
        public function __construct(){
            $this-&gt;buckets = new SplFixedArray($this-&gt;size);
        }
        
        private function hashfunc($key){
            $strlen = strlen($key);
            $hashval=0;
            
            for($i=0;$i&lt;$strlen;$i++){
                $hashval+=ord($key[$i]);
            }
            return $hashval % $this-&gt;size;
        }
    
    
        public function insert($key,$val){
            $index = $this-&gt;Hashfunc($key);
            $this-&gt;buckets[$index]=$val;
        }
        
        public function find($key){
            $index=$this-&gt;hashfunc($key);
            return $this-&gt;buckets[$index];
        }

}
//测试文档
$ht=new HashTable();
$ht-&gt;insert('key1','value1');
$ht-&gt;insert('key2','value2');
echo $ht-&gt;find('key1');
echo '&lt;br/&gt;';
echo $ht-&gt;find('key2');
</code></pre>

<h3 id="hash冲突">Hash冲突</h3>

<p>测试上面的代码</p>

<pre><code>&lt;?php
 
$ht=new HashTable(); 
$ht-&gt;insert('key1','value1');
$ht-&gt;insert('key12','value12');
echo $ht-&gt;find('key1');
echo '&lt;br/&gt;';
echo $ht-&gt;find('key12');
//value12 
//value12
</code></pre>

<p>原因是：不同的关键字通过Hash函数计算出来的Hash值不同。
打印key1和key12都是8</p>

<pre><code>function hashfunc($key){
            $strlen = strlen($key);
            $hashval=0;
            
            for($i=0;$i&lt;$strlen;$i++){
                $hashval+=ord($key[$i]);
            }
            return $hashval % 10;
        }

        echo hashfunc('key1');//8
        echo hashfunc('key12');//8
</code></pre>

<p>也就是说，value1被value12被覆盖了。
解决冲突的常用方法有：开放定址法和拉链法</p>

<p>###拉链法解决冲突
将所有相同的Hash值得关键字节点链接在同一个链表中</p>

<p>拉链法巴相同的Hash值的关键字节点以一个链表链接起来，那么在查找元素是就必须遍历这条链表，
比较链表中每个元素的关键字与查找的关键字是否相等，如果相等就是我们要找的关键字。
因为节点需要保存关键字（key）和数据（value），同时还要记录相同的Hash值的节点，所以创建一个HashNode类来存储这些信息
HashNode结构</p>

<pre><code>&lt;?php
class HashNode{
	    public $key;
	    public $value;
	    public $nextNode;
	    public function __construct($key,$value,$nextNode==null){
	    	$this-&gt;key=$key;
	    	$this-&gt;value=$value;
	    	$this-&gt;nextNode=$nextNode;
    	} 
		}	

</code></pre>

<p>HashNode 有3个属性 $key，$value，$nextNode ，$key是节点的关键字，$value是节点的值，而$nextNode 是指向具有相同Hash值得节点的指针。</p>

<pre><code>//修改插入模式
public function insert($key,$value){
			$index=$this-&gt;hashfunc($key);
			/*创建一个新的节点*/
			if(isset($this-&gt;buckets[$index])){
				$newNode = new HashNode( $key,$value,$this-&gt;buckets[$index]);
			}else{
				$newNode=new HashNode( $key,$value,null);
			}

			$this-&gt;buckets[$index]=$newNode;
			/*保存新节点*/
		}

</code></pre>

<p>1.使用Hash函数计算关键字的Hash值，通过Hash值定位到Hash表的指定位置。
2.如果此位置已经被占用，把新节点的$nextNode指向此节点，否则把新的节点设置为null
3.把新节点保存到Hash表的当前位置</p>

<p>查找</p>

<pre><code>public function find($key){
			$index = $this-&gt;hashfunc($key);
			$current= $this-&gt;buckets[$index];

			while (isset($current)) { /*遍历当前链表*/
				if($current-&gt;key==$key){/*比较当前姐idande关键字*/
					return $current-&gt;value;/*成功*/
				}
				$current=$current-&gt;nextNode;/*比较下一个接点*/
			}
			return  null; /*查找失败*/
		}
</code></pre>

<p>1使用Hash函数计算关键字的Hash值，通过Hash值定位到Hash表的制定位置
2遍历当前链表，比较链表中每个节点的关键字与查找关键字是否相等。如果相等，查找成功。
3如果整个链表都没找到，查找失败</p>

<pre><code>&lt;?php
 class HashNode{
	    public $key;
	    public $value;
	    public $nextNode;
	    public function __construct($key,$value,$nextNode=null){
	    	$this-&gt;key=$key;
	    	$this-&gt;value=$value;
	    	$this-&gt;nextNode=$nextNode;
    		} 
		}	

class NewHashTable{

	private $buckets;
        private $size=10;
        
        public function __construct(){
            $this-&gt;buckets = new SplFixedArray($this-&gt;size);
        }
        
        private function hashfunc($key){
            $strlen = strlen($key);
            $hashval=0;
            
            for($i=0;$i&lt;$strlen;$i++){
                $hashval+=ord($key[$i]);
            }
            return $hashval % $this-&gt;size;
        }

        public function insert($key,$value){
			$index=$this-&gt;hashfunc($key);
			/*创建一个新的节点*/
			if(isset($this-&gt;buckets[$index])){
				$newNode = new HashNode( $key,$value,$this-&gt;buckets[$index]);
			}else{
				$newNode=new HashNode( $key,$value,null);
			}

			$this-&gt;buckets[$index]=$newNode;
			/*保存新节点*/
		}

		public function find($key){
			$index = $this-&gt;hashfunc($key);
			$current= $this-&gt;buckets[$index];

			//var_dump($current );
			//object(HashNode)
			 
			while (isset($current)) { /*遍历当前链表*/
				if($current-&gt;key==$key){/*比较当前姐idande关键字*/
					return $current-&gt;value;/*成功*/
				}
				$current=$current-&gt;nextNode;/*比较下一个接点*/
			}
			return  null; /*查找失败*/
		}

}

$nht=new NewHashTable();
$nht-&gt;insert('key1','value1');
$nht-&gt;insert('key12','value12');
echo $nht-&gt;find('key1');
echo '&lt;br/&gt;';
echo $nht-&gt;find('key12'); 
</code></pre>
<ul class="pa0">
  
</ul>
<div class="mt6">
        
      </div>
    </main>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://gitgitcode.github.io" >
    &copy; 2018 My New Hugo Site
  </a>
    <div>








</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
