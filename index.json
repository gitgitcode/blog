[{"categories":["blog"],"contents":"github项目readme介绍页面有很多徽章，比如测试覆盖率，尝试添加一个看看\nTravis CI api.travis-ci.org 看文档和examlp结果几个问题\n  问题1 go: cannot find main module, but found .git/config\n 执行 go mode init    继续报错，问题2 go get: -t flag is a no-op when using modules\n 修改配置项目 GO111MODULE=auto    最终配置 .travis.yml .travis.yml文件\nlanguage: go go: - \u0026#39;1.10\u0026#39; - \u0026#39;1.11\u0026#39; - \u0026#39;1.12\u0026#39; - \u0026#39;1.13\u0026#39; - \u0026#39;1.14\u0026#39; env: - GO111MODULE=auto before_install: - go get -v golang.org/x/net/html script: - go test -v ./ coveralls.io 项目登录https://coveralls.io 使用自己的账号关联登陆，增加一个新的repository/新的库。 但是这一步时会要求你先关联 Travis CI （Authorize Travis CI for Open Source ）工具，就是上一步 。\n在add rpos 之后的 GO SET UP FOR COVERALLS页面 有一些操作几乎可以不用管不然会遇到各种问题 只要保存好你的repo_token 上传覆盖结果文件时要使用\ngem install coveralls -v 0.8.15 gem \u0026#39;coveralls\u0026#39;, require: false sudo gem install coveralls bundle install Could not locate Gemfile #以上不用管直接到 https://docs.coveralls.io/go 到go文档页面\ngo get golang.org/x/tools/cmd/cover go get github.com/mattn/goveralls 之后执行\ngo test -v -covermode=count -coverprofile=coverage.out #得到一个coverage.out文件 $GOPATH/bin/goveralls -coverprofile=coverage.out -service=travis-ci -repotoken 你的repo_token 到首页得到覆盖率徽章\n","permalink":"https://xtangelo.com/2020/maketesttagsiconforyourprojectongithub/","tags":["github","testing"],"title":"MakeTestTagsBadgeForYourProjectOnGitHub github项目ReadMe增加测试覆盖率徽章"},{"categories":["raspberrypi"],"contents":"设置树莓派屏幕不自动关闭 树莓派开机后有时候希望连接显示器使用一下，活着插上显示器看一下，设置一些东西，毕竟图形界面有些时候方便操作一些。但是如果长时间不动，树莓派可能已经自动进入了休眠模式，屏幕自动黑屏；或是显示器用完后就撤下来很久以后再次接入，无法进入桌面。 这样的情况还是很多的，那么如何配置呢？\n相关软件 LightDM是一个跨桌面环境的显示管理器。它的特点有: 跨桌面 - 支持不同的桌面环境. 支持多种显示技术(X, Wayland, \u0026hellip;). 轻量级 - 低内存使用，高性能. 支持定制会话. 支持远程登录(XDMCP, VNC, XDMCP, 可插拔). 完善的测试组件. 低代码复杂度.\nXserver Xserver - X Window System display server\n配置休眠 编辑 sudo vim /etc/lightdm/lightdm.conf\n找到/xserver-command关键字在 [Seat:*]段下的 #xserver-command 增加 xserver-command=X -s 0 -dpms\n  -s 0 是设置屏幕保护不启用\nsets screen-saver timeout time in minutes.\n  -dpms 是关闭系统的电源节能管理\nenables DPMS (display power management services), where supported. The default state is platform and configuration specific.\n  重启 sudo init 6\n","permalink":"https://xtangelo.com/2020/setraspberrylight/","tags":["pi","Linux"],"title":"SetRaspberryPiLight 设置树莓派屏幕不关闭"},{"categories":["golang"],"contents":"问题场景 准备在读取一个网络地址，获取页面的html标签结构和内容。找到一些方法，是通过读取 http.Get(testUrl)返回的HTTP response body resp *Response 的内容resp.Body再使用net/html库进行读取分析。第一次获取title 标签，第二次获取某个a 标签，但是第二次无法读到资源。\n猜测 猜测指针在遍历时指向了结束，或许在一次读写后关闭了资源。需要再次进行打开读取？ 通过复制的方式多搞几个再操作？\n搜索 #Read Twice resp *Response # Body io.ReadCloser 得到的是继续向下追踪源代码进行思考。 实际上要追根溯源 resp.Body 的Body 是Body io.ReadCloser 而ReadCloser是一个接口\n// ReadCloser is the interface that groups the basic Read and Close methods. type ReadCloser interface { Reader Closer } 这只得到了部分一个部分的解释，但是并没有给出为什么会造成只能读取一次的原理。\n解决 通过\u0026quot;io/ioutil\u0026rdquo; 读取后创建多个副本来进行读取。 ioutil.ReadAll 返回 []byte 之后使用bytes.NewReader(b) 创建一个新的 *Reader 这种思想似乎印证的之前的猜测直接进行复制，但是为什么要使用ReadAll呢？\nfunc main(){ resp, err := http.Get(testUrl) if err != nil { fmt.Println(\u0026#34;errr--------\u0026#34;) } defer resp.Body.Close() b, err := ioutil.ReadAll(resp.Body) //读取  if err !=nil{ panic(err) } //创建一个  reader := bytes.NewReader(b) //创建第二个  readerTitle := bytes.NewReader(b) videoSrc = alink.href(reader) title = alink.Title(readerTitle) ... }  参考： https://stackoverflow.com/questions/43021058/golang-read-request-body/43021236#43021236 https://siongui.github.io/2018/10/28/go-read-twice-from-same-io-reader/ https://books.google.com.hk/books?id=x7JADQAAQBAJ\u0026amp;pg=PA143\u0026amp;lpg=PA143\u0026amp;dq=go+html+parser+%E6%98%AF\u0026amp;source=bl\u0026amp;ots=HI-tth-153\u0026amp;sig=ACfU3U39vp_Xb9w-W3std3wiL39Ede8bug\u0026amp;hl=zh-CN\u0026amp;sa=X\u0026amp;redir_esc=y\u0026amp;sourceid=cndr#v=onepage\u0026amp;q=go%20html%20parser%20%E6%98%AF\u0026amp;f=false https://godoc.org/golang.org/x/net/html https://stackoverflow.com/questions/6564558/wildcards-in-the-pattern-for-http-handlefunc  ","permalink":"https://xtangelo.com/2020/readtwicefromthesameio-reader/","tags":["golang","io.Reader","http"],"title":"How to Read Twice From the Same io.Reader"},{"categories":["linux"],"contents":"原理 通过本地公钥放到远程主机上，这样登录时只需要校验当前机器的公钥就不用密码了。\n 创建你本地公钥 远程主机添加你的公钥 修改远程主机的sshd 配置项目  关闭密码登录 允许密钥登录   重启sshd服务  创建本地公钥 配置项目   将本地公钥内容追加到远程主机的授权文件（authorized_keys）中\n  禁止SSH口令/密码登录 PasswordAuthentication no\n  配置结果 cat /etc/ssh/sshd_config\n# $OpenBSD: sshd_config,v 1.103 2018/04/09 20:41:22 tj Exp $ # This is the sshd server system-wide configuration file. See # sshd_config(5) for more information. # This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin # The strategy used for options in the default sshd_config shipped with # OpenSSH is to specify options with their default value where # possible, but leave them commented. Uncommented options override the # default value. #Port 22 #AddressFamily any #ListenAddress 0.0.0.0 #ListenAddress :: #HostKey /etc/ssh/ssh_host_rsa_key #HostKey /etc/ssh/ssh_host_ecdsa_key #HostKey /etc/ssh/ssh_host_ed25519_key # Ciphers and keying #RekeyLimit default none # Logging #SyslogFacility AUTH #LogLevel INFO # Authentication: #LoginGraceTime 2m PermitRootLogin yes # #StrictModes yes #MaxAuthTries 6 #MaxSessions 10 PubkeyAuthentication yes # Expect .ssh/authorized_keys2 to be disregarded by default in future. #AuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2 AuthorizedKeysFile .ssh/authorized_keys #AuthorizedPrincipalsFile none #AuthorizedKeysCommand none #AuthorizedKeysCommandUser nobody # For this to work you will also need host keys in /etc/ssh/ssh_known_hosts #HostbasedAuthentication no # Change to yes if you don\u0026#39;t trust ~/.ssh/known_hosts for # HostbasedAuthentication #IgnoreUserKnownHosts no # Don\u0026#39;t read the user\u0026#39;s ~/.rhosts and ~/.shosts files #IgnoreRhosts yes # To disable tunneled clear text passwords, change to no here! PasswordAuthentication no #PermitEmptyPasswords no # Change to yes to enable challenge-response passwords (beware issues with # some PAM modules and threads) ChallengeResponseAuthentication no # Kerberos options #KerberosAuthentication no #KerberosOrLocalPasswd yes #KerberosTicketCleanup yes #KerberosGetAFSToken no # GSSAPI options #GSSAPIAuthentication no #GSSAPICleanupCredentials yes #GSSAPIStrictAcceptorCheck yes #GSSAPIKeyExchange no # Set this to \u0026#39;yes\u0026#39; to enable PAM authentication, account processing, # and session processing. If this is enabled, PAM authentication will # be allowed through the ChallengeResponseAuthentication and # PasswordAuthentication. Depending on your PAM configuration, # PAM authentication via ChallengeResponseAuthentication may bypass # the setting of \u0026#34;PermitRootLogin without-password\u0026#34;. # If you just want the PAM account and session checks to run without # PAM authentication, then enable this but set PasswordAuthentication # and ChallengeResponseAuthentication to \u0026#39;no\u0026#39;. UsePAM yes #AllowAgentForwarding yes #AllowTcpForwarding yes #GatewayPorts no X11Forwarding yes #X11DisplayOffset 10 #X11UseLocalhost yes #PermitTTY yes PrintMotd no #PrintLastLog yes #TCPKeepAlive yes #PermitUserEnvironment no #Compression delayed #ClientAliveInterval 0 #ClientAliveCountMax 3 #UseDNS no #PidFile /var/run/sshd.pid #MaxStartups 10:30:100 #PermitTunnel no #ChrootDirectory none #VersionAddendum none # no default banner path #Banner none # Allow client to pass locale environment variables AcceptEnv LANG LC_* # override default of no subsystems Subsystem sftp /usr/lib/openssh/sftp-server # Example of overriding settings on a per-user basis #Match User anoncvs # X11Forwarding no # AllowTcpForwarding no # PermitTTY no # ForceCommand cvs server 延展 ssh-keygen -t rsa -C “any comment can be here”\n-t = The type of the key to generate 密钥的类型 -C = comment to identify the key 用于识别这个密钥的注释 So the Comment is for you only and you can put anything inside. ssh-keygen -t rsa -C \u0026ldquo;注释内容，一般为邮件地址\u0026rdquo;，生成的公钥后面会带上注释\n","permalink":"https://xtangelo.com/2020/ssh%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE/","tags":["ssh","linux","安全"],"title":"ssh 配置免密登录"},{"categories":["blog"],"contents":"重写1 重写的意义是否在于优化？或许是，至少或许有改进的方。毕竟在很长的过去时间范围内大多都是 helleWorld！然后就没有然后了。 依旧在github 上面来回的折腾。无论如何总是有些想法萦绕在那里时不时的冒出来。然后去做吧。\n问题很多 人要各种归因，来回的张望转了一圈有一圈啊。思考总是好的，解释也是有意义的来抹平行为和愿景的落差让自己来接受。有些人靠具体的行动来一点一点填补这种沟壑，有些则望洋兴叹式的转身离去，也不会留下什么。\n 困难的事情尝试3-4此后就容易些了，保持耐心很重要。 经验的积累会带来勇气和信心。 拖延或许是好时，有些时候资源并不是很多，而你又是一个开创者，等待别人的答案也许是个更好的方式。 缓慢的积累势必要的，也是要接受的，因为没有上面加速装置。  好的事情 尝试总是好的，念念不忘必有回想，再次起航就是希望。\n","permalink":"https://xtangelo.com/2020/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99blog/","tags":["blog"],"title":"为什么重写blog"},{"categories":null,"contents":"not test 一个新的博客\n","permalink":"https://xtangelo.com/about/","tags":null,"title":"About"},{"categories":null,"contents":"","permalink":"https://xtangelo.com/search/","tags":null,"title":"Search Results"}]