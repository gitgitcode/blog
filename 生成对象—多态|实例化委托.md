# 生成对象和问题和解决方法

>
        abstract class employee{
        	 
        	protected $name;
        	
        	private static $types = array('minion','cluedup','wellconneted');
######        //对象是实例化委托出来  创建对象策略       	
        	static function recruit($name){ //静态方法
        		$num = rand(1,count(self::$types) -1);
        		$class = self::$types[$num];
        		return new $class($name);
        	}
       
        	function __construct($name){
        		$this->name = $name; 
        	}
        	abstract function fire();
        }
>

        class minion extends employee{//属下
        		function fire(){
        			print "{$this->name} : i'll clear my desk<br/>";
        		}
        }
>

        class nestyboss{
        	private $employee = array();
######  //必须实例化minion 才能获得 minion 对象       
        	function addemployess($employeeName){ 
        		 $this->employee[] = new minion($employeeName);
        	}
                
######      //使用employess 类 多态的方式 但是没有定义创建对象策略
        	function NewAddEmployess(employee $employee){
        		$this->employee[] = $employee;
        	} 
        
        	function projectfails(){
        		if( count($this->employee) >0 ){
        			$emp = array_pop($this->employee);
        			$emp->fire();
        		}
        	}
        }
        
>

        class cluedup extends employee{
        	function fire(){
        		print "$this->name : i'll call my lowyer <br>";
        	}
        }
        
        $boss= new nestyboss();
        $boss->addemployess('A');
######  //必须实例化minion 才能获得 minion 对象  
        $boss->addemployess('B');
        
######  //必须实例化minion 才能获得 minion 对象  
        $boss->NewAddEmployess( new cluedup('xiaoC') );//实例化 
######  //创建对象策略        
        $boss->NewAddEmployess( employee::recruit('harry') );
        
        $boss->projectfails();
        $boss->projectfails();
        $boss->projectfails();
        $boss->projectfails();
        $boss->projectfails();
        
        //-------------------------------------------
       
