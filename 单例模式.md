##      单例模式
####        单例是一种对全局变量的改进，你无法用错误的类型数据覆写一个单例。
        
        单例模式和全局变量都可以在系统中任意地方被访问。同时造成误用。
        可能会导致很强的依赖关系，如果改变单例那么所有使用该单例的类都会受到影响。
>        
##        单例对象的全局化的性质会是程序员绕过类接口定义的通信线路.当单例被使用时，依赖便会隐藏于方法内部，并不会出现在方法声明中，使得依赖难以追踪。

>
        

>
        preferences 
        对象应该可以被系统中任何对象使用
        不应该被存储在被覆写的全局变量中
        不应超过一个preferences对象，假设y设置pref一个属性，
        z对象不需要通过其他对象就可以直接获得该属性的值。

        class preferences{
        	private $props = array();
>
                private static $instance;
                //只能被类调用而不是对象调用

        	private function __construct(){
        
        	}
>        
        	public static function getinstance(){
        		if(empty(self::$instance)){
        			self::$instance = new preferences();
        		}//访问静态属性，当为空时创建对象，并保存在静态属性中
        		return self::$instance;
        	}
        
        	static function static_getinstance(){
        		if(empty(self::$instance)){
        			self::$instance = new static();//通过static关键字调用
        		}
        		return self::$instance;
        	}
        
        	public function setproperty($key,$val){
        		$this->propos[$key] =$val;
        	}
        
        	public function getproperty($key){
        		return $this->propos[$key];
        	}
        
        }
        
        $pref = preferences::getinstance();
        $pref->setproperty("name","jack");
        //echo $pref->getproperty('name');
        unset($pref);//移除引用
        $pref2=preferences::getinstance();
        echo $pref2->getproperty('name'); 
        //jack
        $pref2->setproperty("name","Rosie");
        //
        unset($pref2); 
        $pref3=preferences::static_getinstance();
        echo $pref3->getproperty('name');
        //Rosie
